# Agents-Experiments

This repository explores the capabilities of language model (LM)-based agents, focusing on their evolution, environments, and evaluation designs. We view **data as outputs of computational programs**, including physical systems, where intelligence emerges from compressing these outputs via prediction (e.g., next-token prediction in LLMs). This leads to agentic behaviors through scaling paradigms, including test-time compute, reasoning traces, and agent-environment execution traces. The repo emphasizes Software Engineering (SWE) contexts, decomposing agent scaling and running experiments to test generalization, self-improvement, and economic value.

## Theoretical Foundation

Inspired by Solomonoff Induction, we treat data as artifacts generated by underlying programs. Neural networks approximate these via circuit search (backpropagation), enabling compression that equates to understanding. Scaling laws (e.g., from GPT-3 to GPT-4) predict emergent capabilities, where smooth perplexity reductions yield discrete abilities like in-context learning. In agents, this manifests as reasoning traces (e.g., chain-of-thought) and execution rollouts, converting compute into high-quality data beyond human limits.

- **Data as Compute Artifacts**: Observations are program outputs; agents learn by predicting/compressing them.
- **Compression → Intelligence**: Better prediction implies internal world models, as in LLMs absorbing grammar, facts, and reasoning.
- **Emergence from Scaling**: Power-law data distributions lead to power-law learning curves, with abilities emerging once key eigenfeatures are captured.

## Decomposition of Scaling Agents

Agent scaling decomposes into pre-training, reinforcement learning (RL), and test-time/inference compute, shifting from human data to self-generated experiences. We focus on SWE, where agents handle code generation, debugging, and optimization in verifiable environments (e.g., bash terminals, compilers).

- **Pre-Training Phase**: Builds general priors via next-token prediction on vast datasets. In SWE: Curates code corpora (e.g., [Seed-Coder: Let the Code Model Curate Data for Itself](https://github.com/ByteDance-Seed/Seed-Coder/blob/master/Seed-Coder.pdf)), emphasizing structure over noise.
- **RL Phase (Low to High Compute)**:
  - Low Compute: Elicits pre-trained capabilities (e.g., InstructGPT/ChatGPT via RLHF for instruction following).
  - High Compute: Generates new data/experiences (e.g., self-play in AlphaZero, GRPO in DeepSeek R1). In SWE: Uses verifiers like [leandojo](https://leandojo.org)/[Coq](https://rocq-prover.org) for proof-assisted coding or [Proton](https://github.com/triton-lang/triton/tree/main/third_party/proton) for kernel tuning.
- **Test-Time Compute**: Allocates variable FLOPs per token/problem complexity (e.g., chain-of-thought for hard tasks like Riemann proof vs. simple arithmetic 1+1 = ). In SWE: Agentic search (e.g., Claude Code with tools like [grep](https://github.com/BurntSushi/ripgrep)/[sed](https://linux.die.net/man/1/sed), [CWM: An Open-Weights LLM for Research on Code Generation with World Models](https://scontent.fsvq5-1.fna.fbcdn.net/v/t39.2365-6/557661924_1786317938658057_6511429830363523883_n.pdf?_nc_cat=101&ccb=1-7&_nc_sid=3c67a6&_nc_ohc=3GQUU4R9xVkQ7kNvwGiWHg9&_nc_oc=AdmSmJz9dIlvTy6j7UAjeCbvy0M1NxdexfMGa5-NVoOK3pxIA1l-z1BAi7kw1QymHf8&_nc_zt=14&_nc_ht=scontent.fsvq5-1.fna&_nc_gid=RmnNp_j7zhCoyf5ALi9J4g&oh=00_AfeUSNUHsxyIXlXkypL8pUZGoCIvxjVgbZ17vbn_PgYnCQ&oe=68F71AA9)) over retrival information generation (e.g. [RETRO](https://arxiv.org/abs/2112.04426), enabling long-horizon tasks with function calling.
- **Agentic Path in SWE**: Reasoning → Generalization → Agentic Capabilities. Decomposes into: Tool use (e.g., Codex for CLI integration), memory (infinite context via [context engineering](https://manus.im/blog/Context-Engineering-for-AI-Agents-Lessons-from-Building-Manus)), multimodality (e.g., VLM for code visualization).

This decomposition addresses bottlenecks like data scarcity by converting compute into traces (e.g., reasoning rollouts, self-play games), aiming for ASI-level extrapolation beyond pre-trained support.

## Experiments

We run experiments to probe agent capabilities in controlled settings, generating and analyzing traces for self-improvement.

- **SWE-Focused Experiments**:
  - **Code generation and optimization:** Implement NSA Triton kernels from scratch using LM pairs (e.g., GPT-5/Opus 4.1), tracing rollouts for feedback.
  - **Self-Play and Bootstrapping:** Use nanoGPT as a benchmark for recursive self-improvement; test SPIRAL for multi-agent reasoning in zero-sum coding tasks.
  - **Environment Interactions:** Deploy agents in bash/terminal ([PrimeIntellect environment hub](https://app.primeintellect.ai/dashboard/environments)) or math/coding verifiers (e.g., [DeepSeek-Prover-V2](https://arxiv.org/abs/2504.21801) for subgoal decomposition).
- **General Experiments**:
  - **Web Agents:** Information retrieval via [WebAgent](https://github.com/Alibaba-NLP/DeepResearch) (e.g., WebShaper for synthetic data generation) for Deep Research like searches. [WebDancer](https://,github.com/Alibaba-NLP/WebAgent/tree/main/WebDancer), [bytedn deer-flow](https://github.com/bytedance/deer-flow)
  - **Multimodal:** Test VLM+tools (e.g., [InternVL3.5](https://arxiv.org/abs/2508.18265)) for image-based reasoning in games/coding.
  - **Trajectory Recording:** Capture LLM interactions (e.g., via [bytedn trae-agent](https://github.com/bytedance/trae-agent)) for auditing rollouts, [TRAYECTORY_RECORDING](https://github.com/bytedance/trae-agent/blob/b03b584c09bcff90d74a5469216a6747d3f1fe1a/TRAJECTORY_RECORDING.md#L4).

Experiments emphasize verifiable domains (math, code) to scale RL without human feedback.

## Evaluations

Evaluations measure linear intelligence scaling, avoiding abrupt jumps by reformulating metrics. Focus on traces for reproducibility.

- **SWE Evaluations**:
  - **Coding Traces:** Analyze rollouts (e.g., [AlgoTuner logs,](https://algotune.io/feedback_controller_design_o4-mini.html) CC-bench datasets) for efficiency in kernel design or repo ingestion ([Gitingest](https://github.com/coderamp-labs/gitingest)).
  - [NSA Eval:](https://github.com/Noumena-Network/NSA-Test) Benchmark LM pairs implementing novel algorithms with minimal prior art.
- **General Evaluations**:
  - **Game-as-Eval:** Use GamingAgent for Atari/Tetris/2048 to test agent generalization.
  - **Self-Improvement Benchmarks:** Automated LLM speedrunning on nanoGPT improvements.
  - **Verifier-Based: willccbb/verifiers for RL loops;** measure data efficiency in post-training.

All evals prioritize economic value (e.g., productivity in SWE) and scalability (e.g., parallel test-time compute like Deep Think -> [Grok 4 Heavy](https://x.ai/news/grok-4)).